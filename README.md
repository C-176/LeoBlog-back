# LeoBlog-Back

![](https://img.shields.io/badge/LICENSE-Apache2.0-green.svg)
[![](https://img.shields.io/badge/BLOG-@LeoBlog-red.svg)](http://www.leoblog.icu)

## 介绍

LeoBlog是一个仿知乎的博客系统，旨在提供一个简单易用的博客平台，让用户可以方便地发布、编辑和管理自己的博客。该项目同时集成了在线聊天功能和鱼聪明AI智能助手，能够为用户提供更加全面的博客使用体验。该项目使用Java编写，基于Spring
Boot框架开发，前端使用Vue.js编写。

## 功能列表

* 用户注册和登录：用户可以通过注册和登录功能进行身份验证和授权，以便于进行博客发布和管理等操作。
* 发布、编辑和删除文章：用户可以通过LeoBlog平台进行文章的发布、编辑和删除等操作，便于管理自己的博客。
* 查看文章列表和单篇文章：LeoBlog平台提供了文章列表和单篇文章查看功能，方便用户进行浏览和阅读。
* 在线聊天和私信功能：LeoBlog平台集成了在线聊天和私信功能，用户可以通过平台与其他用户进行交流和互动。
* 集成鱼聪明AI智能助手，实现自主问答功能：LeoBlog平台集成了鱼聪明AI智能助手，能够为用户提供自主问答功能，方便用户进行一些常见问题的解答。

## 安装和使用

该项目需要在本地环境中运行，以下是安装和使用该项目的步骤：

### 克隆或下载该仓库

`git clone https://github.com/C-176/LeoBlog-Back.git`

### 进入项目根目录并修改配置文件

在项目根目录下有一个 `application.yaml / application-dev.yaml`文件，根据您自己的环境配置数据库和Redis信息。

## 构建项目

使用Maven构建项目：

`mvn clean package`

## 运行项目

使用以下命令启动项目：

`java -jar target/leoblog-0.0.1-SNAPSHOT.jar`

后端项目即在本地 **8080** 端口（默认）运行起来了，接下来您可以使用前端项目进行交互。

## 贡献

如果您发现了任何问题或想要改进该项目，请随时提出问题或发送拉取请求。我们非常欢迎您的贡献！

## 许可证

该项目采用 Apache.2.0 许可证 进行许可。详情请参阅 LICENSE 文件。

## 鸣谢

Spring Boot：快速构建应用程序的框架。
MyBatis：优秀的ORM框架，用于将Java对象映射到SQL语句。
Redis：开源的内存数据结构存储，用于缓存和消息队列。
Swagger：API文档化工具。
鱼聪明AI：程序员鱼皮所在公司推出的智能AI助手，为用户提供自主问答功能。

## 开发过程中碰到的问题

### 登录校验的实现方式选择，JWT or Redis？

* JWT的使用方式是 将用户id加密之后作为token发送给客户端，并要求客户端每次访问都携带token，然后服务端就可以通过查看token来解码获取用户id，从而进行验证。
* 使用redis的话，是直接生成一个随机token，然后将该token作为key，将userid作为value存放到redis中，并将该token发送给客户端，然后服务端就可以通过查看token来去redis中获取用户id，从而进行验证。
  下面是这两种方式的优缺点：

JWT 方式的优点：

* 无需在服务端存储 token，减少了服务器端存储的开销。
* 可以支持跨域访问，适用于前后端分离的应用场景。
* 可以通过 token 的签名来防止 token 被篡改或伪造。

JWT 方式的缺点：

* 一旦签发，无法在过期前撤销，用户无法强制退出。
* token 中可能会包含敏感信息，需要适当保护。
* 如果 token 过大，会占用网络带宽和存储空间。
* 需要适当保护 token，例如使用 HTTPS 协议传输，并采用适当的加密算法和签名算法等。

Redis 存放 token 的方式优点：

* 可以随时撤销 token，用户可强制退出。
* 适用于需要频繁更新 token 的场景，例如用户密码修改。
* 可以通过 Redis 的过期机制来自动清除过期的 token。

Redis 存放 token 的方式缺点：

* 需要在服务器端存储 token，增加了服务器端存储的开销。
* 需要建立一套存储和管理机制，增加了系统的复杂性和维护成本。
* Redis 中的 token 存储在内存中，如果未经适当保护，可能会被恶意攻击者攻击窃取。
* Redis 是一个内存数据库，如果 Redis 宕机或发生故障，可能导致 token 无法验证或失效。

#### JWT为什么不支持强制退出？redis需要建立的存储和管理机制指的是key的命名和value的内容，以及如何进行校验吗？

JWT 无法支持强制退出，是因为 JWT 的签发方和验证方是分离的，签发方签发了一个有效期内有效的 JWT，验证方只要验证 JWT
的签名是合法的，就会认为该 JWT 是有效的。JWT 的签发方无法撤销已经签发的 JWT，只能通过设置较短的有效期来缓解该问题。如果需要支持强制退出，可以考虑使用基于
Redis 的方案，允许通过删除 Redis 中的 token 来实现强制退出。

Redis 存储和管理机制主要指的是在 Redis 中建立一套存储和管理方案，包括 token 的生成、存储、验证和删除等，以及如何进行校验。例如，在
Redis 中存储 token 时，可以使用用户 ID 作为 key，token 作为 value，然后设置 token 的过期时间。在验证 token 时，需要根据 token
查询对应的用户 ID，然后进行验证。需要注意的是，在存储和管理 token 时，需要考虑安全性、性能、容灾等方面的问题，以及如何防止
token 被恶意攻击者盗用或伪造。

综上，由于redis在服务端有额外的内存开销，且要考虑数据一致性，并且考虑到登录操作一般只需要登录一次，所以最终选择了JWT的方式。

### 在使用了webSocket的springBoot项目中进行单元测试时，需要指定SpringBootTest注解的webEnvironment属性为WebEnvironment.RANDOM_PORT，否则会报错

在 Spring Boot 项目中使用 WebSocket，需要使用一个 WebSocket 服务器来处理客户端的连接请求。
在 Spring Boot 中，如果你需要在单元测试中使用 IOC 容器，通常需要使用 @SpringBootTest 注解来创建 IOC 容器，并将测试类作为
Spring Boot 应用程序的一部分来运行。这意味着，与应用程序相关的所有组件，包括 WebSocket 相关的组件，都会被 IOC 容器管理。

因此，即使你的测试代码中不涉及 WebSocket，但如果项目代码中有 WebSocket 相关的组件，并且这些组件被注入到 IOC
容器中，那么在单元测试中也需要将 webEnvironment 属性设置为 RANDOM_PORT 或 DEFINED_PORT，以便在测试中启动一个真实的 Web
服务器，并确保 IOC 容器能够正确地管理 WebSocket 相关的组件。

如果你将 webEnvironment 属性设置为 MOCK，那么在测试中启动的是一个模拟的 Web 环境，这个环境可能无法正确地管理 WebSocket
相关的组件，导致测试失败。因此，建议在单元测试中使用真实的 Web 服务器，并将 webEnvironment 属性设置为 RANDOM_PORT 或
DEFINED_PORT。

需要注意的是，在使用 RANDOM_PORT 或 DEFINED_PORT
运行单元测试时，需要确保测试环境中没有其他进程使用了相同的端口，否则可能会导致端口被占用，从而导致测试失败。可以通过配置文件或命令行参数来指定端口号，或者使用随机端口来避免这个问题。

### 拦截器放行的规则问题

由于接口的前缀相同，导致不同的接口需要不同的放行匹配规则，例如`/user/{userId}`和`/user/fans`
，需要分别放行，否则会导致查看用户信息的接口也被拦截，此时如果 `/user/**`就会导致两个接口都被放行或者都被拦截，所以需要使用Ant表达式分别配置。
由于在SpringSecurity中也需要进行相同的放行，所以为了避免重复配置，直接使用自定义注解来进行放行，然后在拦截器中进行判断，如果有该注解，则放行，否则进行拦截。

* 在拦截器中进行注解判断
* 在SpringSecurity 的 configure 方法中进行注解判断

## 游标分页相关问题

### 游标分页的原理

传统的数据库分页是基于limit 和 offset
进行分页的，但是这种方式在数据量大的情况下，会导致性能问题，因为每次查询都需要从头开始查询，然后跳过前面的数据，直到查询到需要的数据，这样的话，查询的数据量会越来越大，导致查询性能越来越差。
游标分页的原理是基于游标字段进行分页，游标字段是指一个可以排序的字段，例如ID，时间等，每次查询时，都会记录上一次查询的游标字段的值，然后下次查询时，会根据游标字段的值进行查询，这样就可以避免每次查询都需要从头开始查询，从而提高查询性能。
在使用游标分页时，需要注意的是，游标字段尽可能是唯一的，来避免数据重复的问题，同时，游标字段的值需要是稳定的，来避免数据不一致的问题。
mysql的游标分页是基于 主键过滤的，redis是基于zset数据结构来实现的。zset天然可以根据score进行排序，通四海提供了响应的api来根据score进行分页查询。

### 游标分页的优缺点

**优点：**

1. 在大数据集和深翻页的场景下性能好，因为无需查询出全部数据在跳过。
2. 在数据数量动态更新的情况下，可以保证每页数据的准确性，因为是基于游标字段进行分页的，而不是基于页码和每页大小进行分页的。
   **缺点：**
1. 游标字段需要是唯一的，来避免数据重复的问题。
2. 游标字段的值需要是稳定的，来避免数据不一致的问题。
3. 无法跳页，只能向下翻页，因为是基于游标字段进行分页的，而不是基于页码和每页大小进行分页的。
4. 在排序变化的情况下，可能会导致数据不准确。
5. 无法进行向前翻页

### 游标字段的选取

1. 唯一，避免重复
2. 稳定，避免数据不一致
3. 有序的，可以根据游标字段进行排序

### 游标分页的应用场景

1. 数据量大，深翻页的场景
2. 数据量动态更新的场景
3. 不需要跳页的场景

### 向下翻页与向上翻页的实现

向下翻页的实现比较简单，只需要根据游标字段的值进行查询即可，
向上翻页 采用在本地保存已查出的所有数据，通过滑动窗口的方式选择展示的数据，当滑动窗口的数据不足时，再向上翻页，查询更多的数据，然后再进行滑动窗口的选择。

### 如果有跟游标重复的数据，如何避免重复

如果跟游标重复的数据，通过维护一个offset来记录当前查询的分页数据中与游标重复的数据的数量，然后在查询时，跳过这些重复的数据即可。
//////////////////
如果重复的数据个数大于每页大小，那么就

### 如果在查询过程中，排序变化了，如何处理

比如，实现排行榜的时候，在向下翻页的时候排序变了，如何解决？
采用快照的方式，每次查询时，都去查询快照，然后根据快照进行分页，这样就可以避免排序变化的问题。
利用定时任务来更新快照，定时任务的执行频率可以根据实际情况来定，如果数据变化频率高，那么可以设置定时任务的执行频率高一些，如果数据变化频率低，那么可以设置定时任务的执行频率低一些。

## 分布式锁

### 项目中哪些地方使用到了分布式锁

### 针对分布式锁可以有哪些优化措施

优化一
目前的锁很明显是悲观锁，请求上来就会先加锁，可以在优化为乐观锁，先去判断当前是否有请求冲突发生，如果没有竞争，则直接操作，如果有则进行加锁，类似于CAS这样的机制，可以少去首次加锁的开销。

优化二
细化锁粒度，参考Innodb的行锁设计，这个需要根据具体的业务场景来考量，在我们的业务中，同一用户的同一请求可以根据索引或键值ID来确定，然后用这类主键ID作为锁空间命名，可以极大程度的细化锁，不会让不同用户的不同请求发生冲突。

优化三
缩小随机等待时间区间，当竞争锁失败后，随机等待多久再去发起竞争呢，等待时间太长没有必要，等待时间过短的话会加剧竞争失败的发生。最初我的值是50-200ms，后来进过jmeter一系列压测，确定在10-50ms这个区间竞争数少，等待时间也短。

优化四（请求折叠）
从SQL的角度来看，能否将这样类似的计费等操作进行合并，不要在代码中取出数据再进行增减，这样可以直接利用Mysql中Innodb的行锁，减少业务层对请求的阻塞。
优化五
将数据库中信息拆分存放，比如将库存信息拆分为多个库存信息，这样可以减少锁的粒度，提高并发度。

### 分布式锁注解和事务注解的顺序，要先生效哪一个？

在给一个方法同时添加分布式锁注解和事务管理注解时，注解的先后顺序是有一定要求的。
通常情况下，应该先应用事务管理注解，再应用分布式锁注解。
原因是事务管理注解需要在方法执行前开启事务，而分布式锁注解需要在方法执行前获取分布式锁。如果先获取分布式锁再开启事务，可能会导致以下问题：

1. 分布式锁的获取可能会引起一定的延迟，如果先获取锁再开启事务，可能会导致事务的开始时间晚于预期，造成事务的覆盖范围不准确。
2. 如果在获取分布式锁时发生了超时或者获取锁失败，可能会导致事务未能正常开启，从而造成事务不一致的问题。

## 设计模式应用

### 装饰器模式

1. 在多线程应用场景下，由于线程中的run方法不能抛出异常，所以在run方法中需要捕获所有的异常，
   然后进行处理，这样会导致代码中充斥着大量的try-catch代码，非常不美观，也不利于代码的维护。如果不进行捕获，那么默认的异常捕获处理器只会对错误信息进行控制太打印，使得错误信息无法被保存或者被通知给前端，
   这个时候需要自己创建异常处理器对异常进行捕获。给线程指定异常处理器的方式有两种，一种是在创建线程时指定，另一种是在线程中指定。

    * 自己实现线程工厂，在newThread()
      方法中指定线程的异常处理器，这种方式会使得针对ThreadPoolTaskExecutor中默认线程工厂的方法失效，比如修改线程名称和线程优先级等。也会使得针对不同的线程池需要创建多个线程工厂，增加工作量。但实际上我们只想将线程增加一个异常处理器，所以这种方法有些繁琐。
    * 将spring提供的线程池ThreadPoolTaskExecutor中生产的线程添加异常处理器。但是该类没有暴露相应的方法。
      同时由于ThreadPoolTaskExecutor本身就间接实现了ThreadFactory接口，所以可以通过装饰器模式来实现。
      实现一个新的线程工厂，将该线程池对象作为成员变量，然后在newThread()方法中调用ThreadPoolTaskExecutor中的newThread()
      方法，然后再对返回的线程对象进行异常处理器的设置。

2.

在登录身份验证的过程中，是采用的双token的方式，登录成功之后生成两个token，一个短期token进行访问的控制，一个长期token作为过期时间的判定，每次在访问的时候解析短期token来验证身份。在短期token过期后，通过长期token验证身份，并生成新的短期token，并通知客户端记录新的短期token，来防止单一token泄露后导致的安全问题。
在进行短期token刷新的过程中，首先会经过springSecurity的身份验证过滤器，两个token都会作为header中的信息经过HttpServletRequest
被过滤器接收，在该过滤器里对短期token的验证与刷新。在生成新的短期token之后，为了保证之后的拦截器能够获取到新的短期token，能够正常解析相关信息，需要将新的短期token放入到HttpServletRequest中，但是HttpServletRequest是不可变的，所以需要使用装饰器模式来实现。
创建一个httpServletRequest装饰器，将HttpServletRequest和一个map作为成员变量，向外提供一个setHeader方法，将传入的键值对存放到map中，然后在getHeader()
将map中的信息作为首选值，就可以实现对请求头的修改。最后将该对象作为参数传入到拦截器中，就可以在拦截器中获取到新的短期token了。

### 注册表模式

将文章评论发布点赞收藏和关注等动作都封装成活动事件枚举类中，创建一个事件注册表工厂，该工厂内部有一个map，以事件类型为key，以具体的活动时间处理器作为value，将事件和事件处理器进行绑定。并且向外暴露执行方法，该方法通过事件类型获取到对应的事件处理器，然后执行事件处理器的处理方法。
事件处理器是一个抽象类，定义了生成消息标题、内容、路由、消息存储的一些方法，由具体的实现类的定义具体的逻辑，并且提供初始化方法，将自己注册到map中。
以这种方式来水平扩展事件处理器，只需要创建一个新的事件处理器，然后在初始化的时候将自己注册到map中，就可以实现新的事件处理逻辑，解耦，方便扩展。
因为每种事件对应的路由、存储和消息提示都是不同的，如果采用switch 或者if
else来进行判断的话，每个方法都要有不同的情况处理，对代码的耦合太高，增加新的事件就要修改原有的代码，代码维护难度太大。

### 策略模式

由于群组聊天采用的是写扩散模式，会将一条消息发送给所有在线的用户。
这种模式下，如果有人刷屏，就会导致服务器的压力过大，所以需要对消息发送进行频率控制。
具体的频控策略实现有集中方案：固定窗口计数、滑动窗口计数、令牌桶、漏桶等。
每种方案都可以独立的进行应用，所以可以采用策略模式来实现。
定义一个策略接口，定义一个策略工厂，将策略接口作为参数传入，
然后在工厂中创建一个map，将策略类型作为key，具体的策略实现类作为value，将策略类型和具体的策略实现类进行绑定。
然后向外暴露一个执行方法，该方法通过策略类型获取到具体的策略实现类，然后执行策略实现类的策略方法。
